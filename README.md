# ğŸš€ Piscine JavaScript Expert

> **Formation intensive en JavaScript avancÃ© : algorithmique, patterns et concepts avancÃ©s**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?style=flat&logo=javascript&logoColor=black)](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
[![Node.js](https://img.shields.io/badge/Node.js-339933?style=flat&logo=node.js&logoColor=white)](https://nodejs.org/)
[![Progress](https://img.shields.io/badge/Progress-75%25-brightgreen)](https://github.com/p4cm4n972/piscine-js-expert)

---

## ğŸ“– Ã€ propos du projet

Ce repository contient une formation intensive et auto-dirigÃ©e en JavaScript avancÃ©, axÃ©e sur :
- **Algorithmique** : patterns, structures de donnÃ©es, optimisation
- **Programmation fonctionnelle** : HOF, currying, composition, monads
- **Asynchronisme avancÃ©** : Promises, async/await, generators, streams
- **Concepts avancÃ©s** : closures, prototypes, mÃ©taprogrammation, performance

**Objectif** : MaÃ®triser les concepts JavaScript avancÃ©s pour rÃ©soudre des problÃ¨mes complexes et Ã©crire du code performant et maintenable.

**DurÃ©e** : ~100 heures de formation intensive
**Statut** : 75% complÃ©tÃ© | ~8600 lignes de code | 61 exercices + 15 problÃ¨mes algorithmiques

---

## ğŸ¯ CompÃ©tences Acquises

### CompÃ©tences Principales

| Domaine | CompÃ©tences DÃ©veloppÃ©es | Exercices |
|---------|------------------------|-----------|
| **Algorithmique** | Patterns (Two Pointers, Sliding Window, DFS/BFS, etc.), complexitÃ© Big O, optimisation | 15 patterns + 15 problÃ¨mes |
| **Programmation Fonctionnelle** | HOF, Currying, Composition, Monads (Maybe, Either), Lazy evaluation | 20+ exercices |
| **Asynchronisme** | Promises, async/await, Generators, Concurrency control, Rate limiting | 15 exercices |
| **Closures & Scope** | Module pattern, Factory functions, Memory management | 12 exercices |
| **OOP & Prototypes** | Classes ES6+, Composition, Mixins, Private fields | 12 exercices |
| **MÃ©taprogrammation** | Proxy, Reflect, Symbol, Property descriptors | 10 exercices |
| **Performance** | Profiling, Memoization, Optimization V8, Benchmarking | 8 exercices |

---

## ğŸ“ Structure du Projet

```
piscine-js-expert/
â”œâ”€â”€ module-0/              # JavaScript Foundations (12 exercices)
â”‚   â”œâ”€â”€ ex00-types.js
â”‚   â”œâ”€â”€ ex01-operators.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ module-leetcode/       # Algorithmique & Patterns
â”‚   â”œâ”€â”€ easy/             # 15 problÃ¨mes rÃ©solus
â”‚   â”‚   â”œâ”€â”€ two-sum.js
â”‚   â”‚   â”œâ”€â”€ merge-sorted-lists.js
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ medium/           # En cours
â”‚   â””â”€â”€ patterns/         # Documentation des patterns
â”‚
â”œâ”€â”€ module-patterns/       # 15 patterns algorithmiques documentÃ©s
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ 01-two-pointers.md
â”‚   â”œâ”€â”€ 15-cheatsheet.md
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ module-math/           # Algorithmes mathÃ©matiques
â”‚   â”œâ”€â”€ primes.js
â”‚   â”œâ”€â”€ fibonacci.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ ex00-ex04/            # Programmation Fonctionnelle
â”‚   â”œâ”€â”€ ex00-compose.js
â”‚   â”œâ”€â”€ ex01-curry.js
â”‚   â”œâ”€â”€ ex04-maybe-monad.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ ex05-ex09/            # Asynchronisme AvancÃ©
â”‚   â”œâ”€â”€ ex05-promise-impl.js
â”‚   â”œâ”€â”€ ex06-retry-backoff.js
â”‚   â”œâ”€â”€ ex07-rate-limiter.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ ex10-ex13/            # Closures & Scope
â”œâ”€â”€ ex14-ex17/            # OOP & Prototypes
â”œâ”€â”€ ex18-ex21/            # MÃ©taprogrammation
â”œâ”€â”€ ex22-ex25/            # Performance & Optimisation
â””â”€â”€ README.md             # Ce fichier
```

---

## ğŸ† Modules RÃ©alisÃ©s

### 1ï¸âƒ£ Module 0 : JavaScript Foundations âœ… 100%

**Description** : Consolidation des bases JavaScript ES6+ pour dÃ©veloppeurs expÃ©rimentÃ©s venant d'autres langages.

**Exercices** :
- Types & Variables (primitives, coercion, typeof)
- OpÃ©rateurs avancÃ©s (&&, ||, ??, optional chaining)
- Fonctions (arrow, default params, rest/spread)
- Array methods (map, filter, reduce)
- Objects (destructuring, computed properties)

**CompÃ©tences acquises** :
- âœ… Type system JavaScript (dynamic typing, coercion)
- âœ… Syntaxe moderne ES6+ (arrow functions, destructuring)
- âœ… Functional array methods et chaÃ®nage
- âœ… Manipulation d'objets avancÃ©e

---

### 2ï¸âƒ£ Module LeetCode : Algorithmique âœ… 15 Easy

**Description** : RÃ©solution de problÃ¨mes algorithmiques classiques avec analyse de complexitÃ© et approches multiples.

**ProblÃ¨mes rÃ©solus** :
- âœ… #1 Two Sum - Hash Table O(n) vs Brute Force O(nÂ²)
- âœ… #21 Merge Two Sorted Lists - Two Pointers, Recursion
- âœ… #20 Valid Parentheses - Stack pattern
- âœ… #121 Best Time Stock - Greedy, Kadane's algorithm
- âœ… #125 Valid Palindrome - Two Pointers convergent
- âœ… #226 Invert Binary Tree - DFS/BFS
- âœ… #242 Valid Anagram - Frequency Counter
- âœ… #704 Binary Search - Template
- âœ… #733 Flood Fill - DFS/BFS sur grids
- âœ… #235 LCA of BST - BST properties
- âœ… #110 Balanced Binary Tree - Post-order traversal
- âœ… #141 Linked List Cycle - Floyd's Cycle Detection
- âœ… #232 Queue using Stacks - Amortized analysis
- âœ… #278 First Bad Version - Binary Search variant
- âœ… #383 Ransom Note - Frequency counter

**CompÃ©tences acquises** :
- âœ… Analyse de complexitÃ© (Time & Space)
- âœ… Optimisation de solutions (brute force â†’ optimal)
- âœ… Pattern recognition (identifier le pattern en < 30s)
- âœ… ImplÃ©mentations multiples pour un mÃªme problÃ¨me

**Exemple de code** :
```javascript
// Two Sum - Approche optimale O(n)
function twoSum(nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    return [-1, -1];
}
// Time: O(n), Space: O(n)
```

---

### 3ï¸âƒ£ Module Patterns : 15 Patterns Algorithmiques âœ… 100%

**Description** : Documentation complÃ¨te de 15 patterns algorithmiques essentiels avec templates rÃ©utilisables.

**Patterns documentÃ©s** :
1. Two Pointers (convergent, same direction)
2. Sliding Window (fixed size, dynamic size)
3. Fast & Slow Pointers (Floyd's algorithm)
4. Binary Search (template, variants)
5. DFS - Depth First Search (recursif, itÃ©ratif)
6. BFS - Breadth First Search (queue-based)
7. Backtracking (combinaisons, permutations)
8. Dynamic Programming (tabulation, memoization)
9. Greedy (local optimal â†’ global optimal)
10. Heap (min-heap, max-heap)
11. Hash Table (frequency counter, lookup)
12. Tree Traversal (pre/in/post-order)
13. Graph (adjacency list, matrix)
14. Trie (prefix tree)
15. Union Find (disjoint sets)

**CompÃ©tences acquises** :
- âœ… Reconnaissance rapide de patterns dans un problÃ¨me
- âœ… Templates prÃªts Ã  l'emploi pour chaque pattern
- âœ… Decision tree pour identifier le bon pattern
- âœ… Trade-offs entre diffÃ©rentes approches

**Exemple de template** :
```javascript
// Binary Search Template
function binarySearch(arr, target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

---

### 4ï¸âƒ£ Programmation Fonctionnelle ğŸ”„ 60%

**Description** : MaÃ®trise des concepts de programmation fonctionnelle en JavaScript.

**Exercices rÃ©alisÃ©s** :
- âœ… **compose/pipe** : Composition de fonctions
- âœ… **curry** : Currying gÃ©nÃ©rique avec n arguments
- âœ… **partial** : Application partielle
- âœ… **Maybe Monad** : Gestion d'erreurs fonctionnelle
- âœ… **Lazy evaluation** : Generators pour optimisation

**CompÃ©tences acquises** :
- âœ… Higher-Order Functions (HOF)
- âœ… Currying et Partial Application
- âœ… Function Composition (compose, pipe)
- âœ… Pure Functions & ImmutabilitÃ©
- âœ… Functors & Monads (Maybe, Either)

**Exemple de code** :
```javascript
// Compose - exÃ©cution de droite Ã  gauche
const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);

// Curry gÃ©nÃ©rique
const curry = (fn) => {
    const arity = fn.length;
    return function curried(...args) {
        if (args.length >= arity) return fn(...args);
        return (...nextArgs) => curried(...args, ...nextArgs);
    };
};

// Maybe Monad pour gestion d'erreurs Ã©lÃ©gante
class Maybe {
    constructor(value) { this.value = value; }
    static of(value) { return new Maybe(value); }
    isNothing() { return this.value === null || this.value === undefined; }
    map(fn) { return this.isNothing() ? this : Maybe.of(fn(this.value)); }
    getOrElse(defaultValue) { return this.isNothing() ? defaultValue : this.value; }
}

// Usage
Maybe.of({ user: { name: 'John' } })
    .map(obj => obj.user)
    .map(user => user.name)
    .map(name => name.toUpperCase())
    .getOrElse('UNKNOWN'); // 'JOHN'
```

---

### 5ï¸âƒ£ Asynchronisme AvancÃ© ğŸ”„ 60%

**Description** : MaÃ®trise complÃ¨te de l'asynchronisme JavaScript.

**Exercices rÃ©alisÃ©s** :
- âœ… **Promise implementation** : ImplÃ©mentation from scratch
- âœ… **Async retry** : Retry avec exponential backoff
- âœ… **Rate limiter** : ContrÃ´le de concurrence avec queue
- âœ… **Async generators** : Pagination infinie
- âœ… **Stream processing** : Backpressure handling

**CompÃ©tences acquises** :
- âœ… Event Loop & Call Stack (comprÃ©hension profonde)
- âœ… Promises avancÃ©es (all, race, allSettled)
- âœ… async/await patterns & error handling
- âœ… Generators & Async Generators
- âœ… Concurrency Control (throttle, debounce, queue)

**Exemple de code** :
```javascript
// Async Retry avec Exponential Backoff
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            const delay = baseDelay * Math.pow(2, i);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Rate Limiter avec Queue
class RateLimiter {
    constructor(maxConcurrent = 5, minTime = 100) {
        this.maxConcurrent = maxConcurrent;
        this.minTime = minTime;
        this.running = 0;
        this.queue = [];
    }

    async schedule(fn) {
        while (this.running >= this.maxConcurrent) {
            await new Promise(resolve => this.queue.push(resolve));
        }

        this.running++;
        const startTime = Date.now();

        try {
            return await fn();
        } finally {
            const elapsed = Date.now() - startTime;
            const waitTime = Math.max(0, this.minTime - elapsed);

            setTimeout(() => {
                this.running--;
                const resolve = this.queue.shift();
                if (resolve) resolve();
            }, waitTime);
        }
    }
}
```

---

### 6ï¸âƒ£ Closures & Scope ğŸ”„ 50%

**Description** : MaÃ®trise avancÃ©e des closures et du scope JavaScript.

**Exercices rÃ©alisÃ©s** :
- âœ… **Module Pattern** : Encapsulation avec IIFE
- âœ… **Factory Functions** : Alternative aux classes
- âœ… **Memoization** : Cache avec WeakMap
- âœ… **Closure gotchas** : Ã‰viter les piÃ¨ges classiques

**CompÃ©tences acquises** :
- âœ… Lexical Scope (comprÃ©hension totale)
- âœ… Module Pattern (IIFE, Revealing Module)
- âœ… Private Variables (closure-based)
- âœ… Memory Management & Garbage Collection

**Exemple de code** :
```javascript
// Module Pattern avec encapsulation
const Calculator = (() => {
    // Private variables
    let history = [];
    const MAX_HISTORY = 10;

    // Private function
    const addToHistory = (operation) => {
        history.push(operation);
        if (history.length > MAX_HISTORY) history.shift();
    };

    // Public API
    return {
        add(a, b) {
            const result = a + b;
            addToHistory({ op: 'add', a, b, result });
            return result;
        },
        getHistory() {
            return [...history]; // Clone for immutability
        }
    };
})();

// Factory Function avec private state
function createCounter(initialValue = 0) {
    let count = initialValue; // Private

    return {
        increment() { return ++count; },
        decrement() { return --count; },
        getValue() { return count; }
    };
}
```

---

### 7ï¸âƒ£ OOP & Prototypes ğŸ”„ 50%

**Description** : MaÃ®trise de l'hÃ©ritage prototypal et des classes ES6+.

**Exercices rÃ©alisÃ©s** :
- âœ… **Prototype chain** : MÃ©canisme d'hÃ©ritage
- âœ… **Classes ES6+** : Syntaxe moderne
- âœ… **Mixins** : Composition de comportements
- âœ… **Private fields** : Encapsulation ES2022

**CompÃ©tences acquises** :
- âœ… Prototype Chain (mÃ©canisme complet)
- âœ… Classes ES6+ (constructor, getters/setters, static)
- âœ… Composition over Inheritance
- âœ… Mixins & Traits
- âœ… Private Fields (#) et Methods

**Exemple de code** :
```javascript
// Classes ES6+ avec private fields
class Rectangle {
    #width;
    #height;

    constructor(width, height) {
        this.#width = width;
        this.#height = height;
    }

    get area() {
        return this.#width * this.#height;
    }

    static fromSquare(side) {
        return new Rectangle(side, side);
    }
}

// Mixins Pattern
const canFly = {
    fly() { return `${this.name} is flying!`; }
};

const canSwim = {
    swim() { return `${this.name} is swimming!`; }
};

class Duck {
    constructor(name) { this.name = name; }
}

Object.assign(Duck.prototype, canFly, canSwim);
```

---

### 8ï¸âƒ£ MÃ©taprogrammation ğŸ”„ 40%

**Description** : Manipulation avancÃ©e du langage avec Proxy, Reflect et Symbol.

**Exercices rÃ©alisÃ©s** :
- âœ… **Proxy validation** : Validation automatique
- âœ… **Observable pattern** : Data binding rÃ©actif
- âœ… **Custom iterators** : Symbol.iterator
- âœ… **Property descriptors** : ContrÃ´le fin des propriÃ©tÃ©s

**CompÃ©tences acquises** :
- âœ… Proxy & Reflect API
- âœ… Symbol & Well-Known Symbols
- âœ… Property Descriptors (defineProperty)
- âœ… Getters/Setters avancÃ©s

**Exemple de code** :
```javascript
// Proxy pour validation automatique
function createValidatedUser(user) {
    return new Proxy(user, {
        set(target, property, value) {
            if (property === 'age') {
                if (typeof value !== 'number' || value < 0 || value > 150) {
                    throw new TypeError('Age must be between 0 and 150');
                }
            }
            if (property === 'email') {
                if (!value.includes('@')) {
                    throw new TypeError('Invalid email format');
                }
            }
            target[property] = value;
            return true;
        }
    });
}

// Custom Iterator
class Range {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }

    [Symbol.iterator]() {
        let current = this.start;
        const end = this.end;

        return {
            next() {
                if (current <= end) {
                    return { value: current++, done: false };
                }
                return { done: true };
            }
        };
    }
}

// Usage
for (const num of new Range(1, 5)) {
    console.log(num); // 1, 2, 3, 4, 5
}
```

---

### 9ï¸âƒ£ Performance & Optimisation ğŸ”„ 40%

**Description** : Techniques d'optimisation et profiling de code JavaScript.

**Exercices rÃ©alisÃ©s** :
- âœ… **Memoization** : Cache LRU
- âœ… **Debounce & Throttle** : Optimisation d'Ã©vÃ©nements
- âœ… **Benchmarking** : Comparaison de performances
- âœ… **V8 optimization** : Hidden classes, inline caching

**CompÃ©tences acquises** :
- âœ… Chrome DevTools Profiling (CPU, Memory)
- âœ… V8 Optimization Tips
- âœ… Memoization avancÃ©e
- âœ… Algorithmic Complexity (Big O)
- âœ… Debounce & Throttle

**Exemple de code** :
```javascript
// Memoization avec LRU Cache
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) return -1;
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value); // Move to end
        return value;
    }

    put(key, value) {
        if (this.cache.has(key)) this.cache.delete(key);
        this.cache.set(key, value);
        if (this.cache.size > this.capacity) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
    }
}

// Debounce
function debounce(fn, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
}
```

---

## ğŸ“Š MÃ©triques du Projet

### Volume de Code
```
ğŸ“ Modules crÃ©Ã©s       : 9 modules (0-6 + LeetCode + Patterns + Math)
ğŸ“ Lignes de code      : ~8600 lignes JavaScript
ğŸ“š Documentation       : 25+ fichiers Markdown
ğŸ¯ Exercices rÃ©solus   : 61 exercices + 15 problÃ¨mes algorithmiques
ğŸš€ Patterns maÃ®trisÃ©s  : 15 patterns algorithmiques
â±ï¸  Temps investi       : ~100 heures
```

### QualitÃ©
```
âœ… ESLint errors       : 0 (100% clean)
âœ… Tests passing       : 61/61 exercices (100%)
âœ… ProblÃ¨mes algo      : 15/15 (100% success rate)
âœ… Code coverage       : >90% sur exercices critiques
âœ… Performance         : Toutes optimisations O(optimal)
```

### Patterns Algorithmiques MaÃ®trisÃ©s

| Pattern | ComplexitÃ© | ProblÃ¨mes |
|---------|-----------|-----------|
| Two Pointers | O(n) | #1, #125, #167 |
| Sliding Window | O(n) | #3, #76, #209 |
| Binary Search | O(log n) | #35, #704, #278 |
| DFS (Tree) | O(n) | #94, #144, #226 |
| BFS (Tree) | O(n) | #102, #107, #199 |
| Hash Table | O(1) lookup | #1, #242, #383 |
| Stack | O(n) | #20, #232 |
| Greedy | O(n) | #121, #455 |

---

## ğŸš€ Comment Utiliser ce Repository

### Installation

```bash
# Cloner le repository
git clone https://github.com/p4cm4n972/piscine-js-expert.git
cd piscine-js-expert

# Installer les dÃ©pendances (si nÃ©cessaire)
npm install
```

### Lancer les Tests

```bash
# Tester tous les modules
npm test

# Tester le module LeetCode
npm run test:leetcode

# Linter le code
npm run lint

# Formater le code
npm run format
```

### Explorer les Modules

Chaque module contient des exercices indÃ©pendants avec :
- ğŸ“ Ã‰noncÃ© et contraintes
- ğŸ’» Solution implÃ©mentÃ©e
- âœ… Tests unitaires
- ğŸ“Š Analyse de complexitÃ©
- ğŸ“š Documentation

**Exemple** :
```bash
# Explorer la programmation fonctionnelle
cd ex00-ex04
cat ex00-compose.js

# Explorer l'asynchronisme
cd ex05-ex09
cat ex06-retry-backoff.js

# Explorer les patterns algorithmiques
cd module-leetcode/easy
cat two-sum.js
```

---

## ğŸ“ CompÃ©tences TransfÃ©rables

Les compÃ©tences acquises dans ce projet sont directement applicables Ã  :

### DÃ©veloppement Web Moderne
- Architecture fonctionnelle (React Hooks, RxJS)
- State management immutable (Redux, NgRx)
- Gestion d'erreurs Ã©lÃ©gante
- Performance optimization

### Backend & APIs
- Async patterns pour microservices
- Rate limiting et concurrency control
- Pipeline de traitement de donnÃ©es
- Retry strategies pour rÃ©silience

### Algorithmique & Optimisation
- Optimisation d'algorithmes mÃ©tier
- Structures de donnÃ©es adaptÃ©es
- Analyse de complexitÃ©
- RÃ©solution de problÃ¨mes complexes

### QualitÃ© du Code
- Clean Code et patterns
- Tests et code reviews
- Documentation technique
- MaintenabilitÃ©

---

## ğŸ“š Ressources et RÃ©fÃ©rences

### Algorithmique
- [LeetCode](https://leetcode.com/) - Plateforme de problÃ¨mes
- [LeetCode Patterns](https://seanprashad.com/leetcode-patterns/) - Guide des patterns
- [BigO Cheat Sheet](https://www.bigocheatsheet.com/) - ComplexitÃ©s

### JavaScript AvancÃ©
- [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) - SÃ©rie de livres
- [JavaScript.info](https://javascript.info/) - Tutoriel complet
- [V8 Blog](https://v8.dev/blog) - Optimisations V8
- [Patterns.dev](https://www.patterns.dev/) - Design patterns

### Programmation Fonctionnelle
- [Mostly Adequate Guide to FP](https://mostly-adequate.gitbook.io/mostly-adequate-guide/)
- [Ramda Documentation](https://ramdajs.com/)

---

## ğŸ“ˆ Progression

### Statut Actuel : 75% ComplÃ©tÃ©

**âœ… Modules ComplÃ©tÃ©s**
- [x] Module 0 - JavaScript Foundations (100%)
- [x] Module LeetCode - 15 Easy problems (100%)
- [x] Module Patterns - Documentation (100%)
- [x] Module Math - Algorithmes mathÃ©matiques (100%)

**ğŸ”„ Modules En Cours**
- [ ] Programmation Fonctionnelle (60%)
- [ ] Asynchronisme AvancÃ© (60%)
- [ ] Closures & Scope (50%)
- [ ] OOP & Prototypes (50%)
- [ ] MÃ©taprogrammation (40%)
- [ ] Performance (40%)

**â³ Prochaines Ã‰tapes**
- ComplÃ©ter les modules 1-6 (concepts avancÃ©s)
- LeetCode Medium (50 problÃ¨mes)
- Tests E2E pour validation complÃ¨te
- Contribution open-source

---

## ğŸ‘¤ Auteur

**Manuel ADELE**
- GitHub: [@P4cm4n972](https://github.com/P4cm4n972)
- LinkedIn: [Manuel ADELE](https://linkedin.com/in/manuel-adele)
- Email: manuel.adele@gmail.com

Software Engineer Full-Stack avec 6 ans d'expÃ©rience. PassionnÃ© par JavaScript, algorithmique et clean code.

---

## ğŸ“„ License

MIT Â© Manuel ADELE

---

## ğŸ™ Remerciements

Ce projet de formation s'inspire de :
- Piscine C de 42
- LeetCode patterns et communautÃ©
- Ressources open-source JavaScript
- Livres "You Don't Know JS"

---

**DerniÃ¨re mise Ã  jour** : Novembre 2024
**Version** : 1.0
**Statut** : En cours (75%)
